@document.meta
	title: The Neorg 0.1 File Format Spec
	description: A draft of the 0.1 Neorg File Format (NFF-0.1) specification
	author: Vhyrro
end

*_NOTE: This spec is incomplete and still in progress, expect some changes!_*

Data can be represented with the magic of `@`. In the above data tag we specify the document's data.



* About the Neorg format
  *** The concept
      - The idea behind Neorg is to make org _easier_, more readable *and* extensible - all while keeping it familiar.
      - Neorg will refrain as much as possible from creating ambiguity, meaning there'll be only *_one_* way of doing things. For example, `-` at the beginning
      of a line means an unordered list and an unordered list *only*. No need for 50 different ways of writing a list.
      - Allow for defining static data and ways to call internal lua functions that will be able to dynamically morph the document as you go.



* Keybinds
Since this is neovim, we want keybinds to do most of the work. Good news! That's exactly what neorg's gonna do.
By default the neorg 'prefix' is <Leader>o, meaning all keybinds defined by neorg modules will be stored here. This can be changed, of course.
To insert a heading, you can do <Leader>oih (<Leader> org insert heading) - makes sense, right?
You get the point, it's supposed to be intuitive. Don't like the keybinds? Don't worry - all neorg keybinds for *every* module are remappable, whether the module's creator likes it or not.



* Nifty tricks
Look mum, I can write my own name here: @document.meta.author!
Whenever this document will get rendered in another format or whenever `:Neorg show data_references` gets triggered the above value will get replaced with "Vhyrro"! Pretty neat, eh?



1) Ordered lists can be done like this!
2. Or like this! This one is up to your preference
3) Does it break the promise we made about removing ambiguity?
4. Nope, since here the situation is a bit different, you see



Since things like 1) and 2. are way more commonly interchangeable in everyday writing we allow both as to not anger half of the human race at once.



* Drawbacks, and things we will do to make things less ambiguous
Developing a new format is extremely difficult - I, personally, would love to change a lot of things up to be my way. But it's not so simple.
This is an open source project, and introducing something non-familiar to others would cause a lot of outrage. I get that!
That's why *most* of the basic markdown things will be the same. These changes may seem rather odd at first, but please stick with me here, I go further in depth later:
- _this_ means italic.
- *This* is bold
- *_This is bold and italic_*
- ~~Strikethrough~~
- * This is a heading 
- ** And a subheading
- *** You get the idea

Soo, why like this? Let's consider I _did_ use regular markdown syntax, new tell me this:
- How do i parse `**this* text**`? Look at it a few times and tell me that doesn't look confusing. Now look at the norg version: *_this_ text**.
  Wow, would you look at that, it's almost like it's more readable, eh? Way less complex to parse, too!
  `this` becomes italic and bold, `text` is just bold and the text ends with a regular `*` character.


Hey look a TODO list!
- [ ] Do something
- [*] Do something else (partially done):
      - [ ] Extra stuff
      - [x] Even more stuff
- [x] Done task


* Modifiers inbetween letters of a word and modifier rules

** Modifier rules
	Before we talk about modifier rules, let's get some theory out of the way:
	- Modifiers - characters or sequences of characters that change the way text is displayed. They appear usually in the middle or end of a line, but can also
	show up at the beginning.
	- Paragraphs - a paragraph ends whenever two consecutive line breaks are encountered or whenever something that must be rendered on a new line is encountered.
	               This means that if a list or codeblock is found it will terminate the current paragraph.
		       If you do not want a list to be accidentally created, read about the `~` modifier below.

Now, let's commence:
	Things like `*`, `_`, `~~` are all modifiers.
	Opening modifiers are valid whenever one or more whitespace characters can be found before the modifier and whenever there is an alphanumeric character
	or other modifier after itself.
	Closing modifiers are valid if they do not have any preceding whitespace and have one or more whitespace characters or other modifiers afterwards.
	If a modifier is invalid or no closing modifier can be found before the end of a paragraph it is instead treated as a regular character and rendered as such.

** Doing th*is* in .norg
	Considering the above rules it seems there is no way to put modifiers inbetween the letters of a word, correct? Wrong. It is possible, however it is
	considerably more explicit than in regular markdown. It is done l-*ik*-e so. It may seem very odd at first glance, but it is something rather
	intuitive and easy to get used to. You are already used to linking words on other lines li-
	ke this in everyday writing, so it makes sense here too, correct? Also since inter-letter modifiers are rather uncommon it makes sense to make it a
	tad harder to write but muuuch easier to parse and interpret. This nicely brings us on to the power of the `-` modifier, also known as the linking modifier.

	Its rules allow it to do a couple of useful things, so let's talk about them:
	- As you may have already realized, this is one of those modifiers that do not adhere to the rules mentioned in [the modifier rules](**modifier-rules)
	  The linking modifier is valid whenever it has an alphanumeric character (not whitespace) before itself and another alphanumeric character or newline afterwards.
	  If it doesn't meet these requirements it will be interpreted as either a regular `-` char or an unordered list depending on the positioning and context
	  of said modifier.
	- It can be used to connect other modifiers with regular text, like t-_his_-.
	- It can be used to connect words on lines together and force the continuation of a paragraph, meaning thi-
	  s will be rendered as:
	  `(...) force the continuation of a paragraph, meaning this will be rendered as:`

** The `~` operator, `-`s cousin
	The `~` operator works the same way that `-` does, however it can only appear at the end of a line and cannot have precending whitespace.
	What does it do? It tells the parser to not terminate the paragraph, no matter what. Take this for example:

	@code
		It is crazy that this 5 year old kid has the reasoning of a man who is
		20. Absolutely astonishing.
	end

	How would this get interpreted? Well, the parser would think that `20.` is the beginning of an ordered list, and the paragraph would get terminated.
	However, if we do this instead:

	@code
		It is crazy that this 5 year old kid has the reasoning of a man who is~
		20. Absolutely astonishing.
	end

	It will instead tell the parser that the paragraph must continue and it will join the two lines with a space inbetween.
	This can be done for anything, meaning:

	@code
		If I write something~
		- like this -~
		it won't interpret the second line as an unordered list, rather, it will cause the line to look like so:

		If I write something - like this - it won't interpret (...)
	end

	If you do not want a space to be inserted when two lines are joined use the `-` modifier instead.



* Extra features
Neorg will also be able to fuzzy find and filter *all* types of data within the file with `telescope.nvim`, pretty neat eh?
You'll be able to fuzzy find *only* headings, *only* content in tables, *only* code blocks, *only* todo items etc.



@code
	Generic code block
end

@code.lua

	print("Hey look a code block")

end

@code.cpp

	#include <iostream>

	int main()
	{
		[&cout = std::cout](const char* message) -> auto { cout << message; }("Wow look an overcomplicated print statement with lambdas and unnecessary amount of syntax sugar.\n");
	}

end


* Carry-over tags
By prepending a command with `$` instead of `@`, it will take the current attribute and its parameters and apply them to the next statement _only_.
Thanks to this the tag doesn't require an `end` statement.


@formatting(center, colour = blue)
	* That's it for now! [Star the project, or else...](https://github.com/vhyrro/neorg)
end

^ The above label centers the text whenever it's about to get rendered as HTML or Markdown etc.


$comment The above data tag tells neorg to center the text inbetween the definition and `end` statement

@comment 

	Note that `@formatting(center, colour = blue)` is equivalent to:

	@code
		@formatting.center
			@formatting.colour = blue
				* That's it for now! (...)
			end
		end
	end

	or

	@code
		$formatting.center
		$formatting.colour = blue
		* That's it for now! (...)
	end

	_or_

	@code
		$formatting(center, colour = blue)
		* That's it for now! (...)
	end

end

*NOTE:* using a carry-over tag means that only the heading will be centered and blue, but the rest of the text will not be.
Since the carry-over tag is only supposed to carry the current attributes over to the next statement it will not affect anything else.
For affecting more than one statement or paragraph make sure to use data tags (the ones that utilize the `@` symbol and `end` keyword) instead.
